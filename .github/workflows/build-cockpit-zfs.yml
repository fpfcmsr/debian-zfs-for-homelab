name: Build cockpit-zfs (Debian trixie, monthly + APT repo)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 6 1 * *" # monthly, 06:00 UTC on the 1st

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  trixie:
    runs-on: ubuntu-latest
    container: debian:trixie-slim

    env:
      DEB_MAINTAINER: "GitHub Actions <noreply@github.com>"
      DIST: "trixie"
      COMPONENT: "main"

    steps:
      - name: Configure APT (deb822, include contrib) + update
        shell: bash
        run: |
          set -euxo pipefail
          . /etc/os-release
          DIST="${VERSION_CODENAME:-trixie}"
          cat >/etc/apt/sources.list.d/debian.sources <<EOF
          Types: deb
          URIs: http://deb.debian.org/debian
          Suites: ${DIST} ${DIST}-updates
          Components: main contrib
          Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg

          Types: deb
          URIs: http://security.debian.org/debian-security
          Suites: ${DIST}-security
          Components: main contrib
          Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg
          EOF
          rm -f /etc/apt/sources.list /etc/apt/sources.list.d/*.list || true
          apt-get update

      - name: Install build toolchain & deps
        shell: bash
        run: |
          set -euxo pipefail
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            ca-certificates curl jq rsync pkg-config \
            build-essential dpkg-dev fakeroot debhelper devscripts \
            python3 python3-pip python3-packaging \
            git make gzip tar findutils xz-utils \
            gnupg apt-utils \
            nodejs npm
          echo "PIP_BREAK_SYSTEM_PACKAGES=1" >> "$GITHUB_ENV"
          if command -v corepack >/dev/null 2>&1; then corepack enable || true; fi

      # --- Get latest cockpit-zfs release & extract ---
      - name: Get latest 45Drives/cockpit-zfs release tag
        id: latest
        shell: bash
        run: |
          set -euo pipefail
          tag="$(curl -fsSL https://api.github.com/repos/45Drives/cockpit-zfs/releases/latest | jq -r '.tag_name')"
          [ -n "$tag" ] && [ "$tag" != "null" ] || { echo "::error::Could not get latest tag"; exit 1; }
          echo "tag=$tag" >> "$GITHUB_OUTPUT"

      - name: Download+extract cockpit-zfs source tarball
        id: fetch_src
        shell: bash
        run: |
          set -euxo pipefail
          TAG="${{ steps.latest.outputs.tag }}"
          curl -fL "https://github.com/45Drives/cockpit-zfs/archive/refs/tags/${TAG}.tar.gz" -o src.tar.gz
          tar -xzf src.tar.gz
          SRC_DIR="$(echo cockpit-zfs-*/ | cut -d/ -f1)"
          test -d "$SRC_DIR"
          echo "src=$SRC_DIR" >> "$GITHUB_OUTPUT"

      - name: Extract Cython pin from README (fallback to 0.29.35)
        id: cython
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ steps.fetch_src.outputs.src }}"
          ver="$(grep -Eo 'Cython( *==| *:| *=) *[0-9]+\.[0-9]+(\.[0-9]+)?' "$SRC/README.md" \
                 | head -n1 | sed -E 's/.*[=: ] *//')"
          [ -n "${ver:-}" ] || ver="0.29.35"
          echo "version=$ver" >> "$GITHUB_OUTPUT"
          echo "Using Cython==$ver"
          pip3 install "Cython==$ver"

      # --- Build cockpit-zfs with your flow, but only run ./configure if it exists ---
      - name: Build cockpit-zfs (configure if present, otherwise native build)
        shell: bash
        working-directory: ${{ steps.fetch_src.outputs.src }}
        run: |
          set -euxo pipefail

          if [ -x ./configure ]; then
            ./configure --prefix=/usr
            make -j"$(nproc)"
          else
            echo "No ./configure in this release; trying native build."
            if [ -f Makefile ]; then
              make -j"$(nproc)" || true
            fi
            # If no dist yet, try Node build
            if [ ! -d dist ]; then
              corepack enable || true
              if [ -f yarn.lock ]; then
                (corepack yarn install --immutable) || corepack yarn install
                corepack yarn build || corepack yarn run build || true
              elif [ -f package.json ]; then
                npm ci || npm i
                npm run build || true
              fi
            fi
            test -d dist || { echo "::error::No build artifacts (dist/) produced"; exit 1; }
          fi

      - name: Stage install tree (make install if available, else manual stage)
        id: stage
        shell: bash
        run: |
          set -euxo pipefail
          SRC="${{ steps.fetch_src.outputs.src }}"
          STAGE="$PWD/stage"
          mkdir -p "$STAGE"

          # Try "make install" if there is an install target
          if make -C "$SRC" -n install >/dev/null 2>&1; then
            make -C "$SRC" install DESTDIR="$STAGE"
          else
            echo "No usable 'make install' target; staging from built 'dist/'."
            # Discover module name from manifest.json
            if [ -f "$SRC/manifest.json" ]; then
              MODULE="$(jq -r '.name // empty' "$SRC/manifest.json" || true)"
            elif [ -f "$SRC/dist/manifest.json" ]; then
              MODULE="$(jq -r '.name // empty' "$SRC/dist/manifest.json" || true)"
            else
              MODULE=""
            fi
            [ -n "$MODULE" ] || MODULE="zfs"

            INSTALL_ROOT="$STAGE/usr/share/cockpit/${MODULE}"
            mkdir -p "$INSTALL_ROOT"
            if [ -d "$SRC/dist" ]; then
              rsync -a --delete "$SRC/dist/" "$INSTALL_ROOT/"
            else
              rsync -a --delete --exclude '.git' --exclude 'node_modules' --exclude '.github' \
                --exclude '*.yml' --exclude '*.yaml' --exclude 'packaging' \
                "$SRC/" "$INSTALL_ROOT/"
            fi
          fi

          # sanity: ensure a cockpit manifest ended up in the staged tree
          test -n "$(find "$STAGE/usr/share/cockpit" -maxdepth 2 -name manifest.json -print -quit)" || {
            echo "::error::No Cockpit manifest.json found after staging"; exit 1; }

          # Derive metadata for packaging
          MODDIR="$(find "$STAGE/usr/share/cockpit" -mindepth 1 -maxdepth 1 -type d | head -n1)"
          MODULE="$(basename "$MODDIR")"
          VER=""
          if [ -f "${SRC}/package.json" ]; then
            VER="$(jq -r '.version // empty' "${SRC}/package.json" || echo "")"
          fi
          [ -n "$VER" ] || VER="${{ steps.latest.outputs.tag }}"
          VER="${VER#v}"

          echo "MODULE=$MODULE" >> "$GITHUB_ENV"
          echo "VERSION=$VER"   >> "$GITHUB_ENV"

      - name: Build .deb 
        id: deb
        shell: bash
        run: |
          set -euxo pipefail
          STAGE="$PWD/stage"
          mkdir -p "$STAGE/DEBIAN"
          {
            printf 'Package: cockpit-zfs\n'
            printf 'Priority: optional\n'
            printf 'Section: admin\n'
            printf 'Maintainer: %s\n' "$DEB_MAINTAINER"
            printf 'Architecture: all\n'
            printf 'Depends: cockpit, python3, sqlite3, python3-pyzfs\n'
            printf 'Description: Cockpit plugin for administering ZFS\n'
            printf ' Web UI (Cockpit) module for managing ZFS pools, datasets, and snapshots.\n'
          } > "$STAGE/DEBIAN/control"

          printf '%s\n' '#!/bin/sh' 'set -e' \
            'if command -v systemctl >/dev/null 2>&1; then' \
            '  systemctl try-reload-or-restart cockpit.service 2>/dev/null || true' \
            'fi' 'exit 0' > "$STAGE/DEBIAN/postinst"
          chmod 0755 "$STAGE/DEBIAN/postinst"

          OUT="$PWD/artifacts"; mkdir -p "$OUT"
          DEB="cockpit-zfs_${VERSION}_all.deb"
          dpkg-deb --build "$STAGE" "$OUT/$DEB"
          echo "path=$OUT/$DEB" >> "$GITHUB_OUTPUT"
          echo "name=$DEB"      >> "$GITHUB_OUTPUT"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.deb.outputs.name }}
          path: ${{ steps.deb.outputs.path }}
          if-no-files-found: error

      # ---------- Build/Update signed APT repo on GitHub Pages ----------
      - name: Checkout existing gh-pages (if present)
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: site
        continue-on-error: true

      - name: Prepare APT repo tree
        shell: bash
        run: |
          set -euxo pipefail
          SITE="$PWD/site"
          mkdir -p "$SITE/pool/${COMPONENT}/c/cockpit-zfs"
          cp -f "${{ steps.deb.outputs.path }}" "$SITE/pool/${COMPONENT}/c/cockpit-zfs/"

      - name: Import GPG key for signing
        shell: bash
        env:
          GPG_PRIVATE_KEY: ${{ secrets.APT_GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
          GPG_KEY_ID: ${{ secrets.APT_GPG_KEY_ID }}
        run: |
          set -euxo pipefail
          export GNUPGHOME="$PWD/.gnupg"
          mkdir -p "$GNUPGHOME"; chmod 700 "$GNUPGHOME"
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          if [ -z "${GPG_KEY_ID:-}" ]; then
            GPG_KEY_ID=$(gpg --batch --list-secret-keys --keyid-format=long | awk '/^sec/{print $2}' | sed 's|.*/||' | head -n1)
          fi
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> "$GITHUB_ENV"
          SITE="$PWD/site"
          mkdir -p "$SITE/keys"
          gpg --batch --armor --export "$GPG_KEY_ID" > "$SITE/keys/apt-key.asc"
          gpg --batch --export "$GPG_KEY_ID" > "$SITE/keys/apt-key.gpg"
          echo "GPG_PASSPHRASE=${GPG_PASSPHRASE}" >> "$GITHUB_ENV"

      - name: Generate APT metadata & sign
        shell: bash
        run: |
          set -euxo pipefail
          ARCH="$(dpkg --print-architecture)"
          SITE="$PWD/site"
          DIST="${DIST}"
          COMP="${COMPONENT}"

          mkdir -p "$SITE/dists/$DIST/$COMP/binary-$ARCH" "$SITE/dists/$DIST/$COMP/binary-all"

          apt-ftparchive -o APT::FTPArchive::Architecture=$ARCH packages "$SITE/pool/$COMP" \
            > "$SITE/dists/$DIST/$COMP/binary-$ARCH/Packages"
          gzip -kf "$SITE/dists/$DIST/$COMP/binary-$ARCH/Packages"

          apt-ftparchive -o APT::FTPArchive::Architecture=all packages "$SITE/pool/$COMP" \
            > "$SITE/dists/$DIST/$COMP/binary-all/Packages"
          gzip -kf "$SITE/dists/$DIST/$COMP/binary-all/Packages"

          {
            printf 'APT::FTPArchive::Release::Origin "GitHub Pages";\n'
            printf 'APT::FTPArchive::Release::Label "GitHub Pages";\n'
            printf 'APT::FTPArchive::Release::Suite "%s";\n' "$DIST"
            printf 'APT::FTPArchive::Release::Codename "%s";\n' "$DIST"
            printf 'APT::FTPArchive::Release::Architectures "%s";\n' "$ARCH all"
            printf 'APT::FTPArchive::Release::Components "%s";\n' "$COMP"
            printf 'APT::FTPArchive::Release::Description "APT repo for cockpit-zfs";\n'
          } > "$SITE/release.conf"

          apt-ftparchive -c "$SITE/release.conf" release "$SITE/dists/$DIST" > "$SITE/dists/$DIST/Release"

          export GNUPGHOME="$PWD/.gnupg"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              -u "$GPG_KEY_ID" --clearsign \
              -o "$SITE/dists/$DIST/InRelease" "$SITE/dists/$DIST/Release"

          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
              -u "$GPG_KEY_ID" -abs \
              -o "$SITE/dists/$DIST/Release.gpg" "$SITE/dists/$DIST/Release"

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
